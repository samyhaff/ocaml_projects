(* question 2 *)let somme a b =  let n = Array.length a in  let c = Array.make_matrix n n true in  for i = 0 to n-1 do    for j = 0 to n-1 do      c.(i).(j) <- a.(i).(j) || b.(i).(j)    done  done ;  c ;;let produit a b =  let n = Array.length a in  let d = Array.make_matrix n n true in  let rec aux i j k = match k with    | k when k = n -> false    | k            -> a.(i).(k) && b.(k).(j) || aux i j (k+1)  in  for i = 0 to n-1 do    for j = 0 to n-1 do      d.(i).(j) <- aux i j 0    done   done ;  d ;;(* question 3 *)let accessible a =  let n = Array.length a in  let id = Array.make_matrix n n false in  for i = 0 to n-1 do    id.(i).(i) <- true  done ;  let b = somme a id in  let rec aux k = match k with    | 1 -> b    | k when k mod 2 = 0 -> let d = aux (k/2) in produit d d    | k -> let d = aux (k/2) in produit b (produit d d)  in aux n ;;(* question 4 *)let rec affiche_chemin l = match l with  | []   -> ()  | [t]  -> print_int t ; print_newline ()  | t::q -> print_int t ; print_string " -> " ; affiche_chemin q ;;let chemins a i j =  let n = Array.length a in  let rec aux chem exclus i k = match k with    | _ when i = j                         -> [[j]]    | k when k = n                         -> chem    | k when a.(i).(k) && not (List.mem k exclus) -> 
       let lst = List.map (function l -> i::l) (aux [] (i::exclus) k 0)        in aux (lst @ chem) exclus i (k+1)    | k                                   -> aux chem exclus i (k+1)  in List.iter affiche_chemin (aux [] [] i 0) ;;(* tests *)let a = [| [| false; true; false; true; false; true |] ;           [| false; false; true; true; true; false |] ;	   [| false; true; false; true; false; false |] ;	   [| false; false; false; false; true; false |] ;	   [| false; false; false; false; false; false |] ;	   [| false; true; false; false; false; false |] |] ;;accessible a ;;chemins a 0 4 ;;





